


\section{Contribution}

\subsection{Network Protocol Architecture}



\subsection{Steve: A Network Protocol Specification Language}

\frame{\frametitle{Steve's Terms}

  \begin{flushleft}
  \begin{align*}
  t &::= t~t ~|~ \lambda x:\tau.t ~|~ x ~|~ c ~|~
    \mbox{if } t \mbox{ then } t \mbox{ else } t \\
     &~~|~
    \mbox{let } x:\tau = t \mbox{ in } t ~|~ 
    K~\overline{t} ~|~
    \mbox{case } t \mbox{ of } \{
      \overline{K~\overline{t} \rightarrow t} \}\\
    &~~|~
    \mbox{uint } t~t ~|~ \mbox{ array } \tau~t ~|~ t[t] ~|~ t.\ell ~|~
    id \{ \overline{\ell = t} \} \\
    &~~|~
    \mbox{data } id = \overline{K \overline{\tau}} ~|~
    \mbox{pdu } id = \{ \overline{\ell = \tau} \} \\
    &~~|~ \mbox{enum } id = \{\overline{\tau \rightarrow  \mbox{Bool}, \tau}\}
  \end{align*}
\end{flushleft}
}

\frame{\frametitle{Kinds and Types of Steve} 
\begin{flushleft}
   \begin{align*}
      K &::= \star ~|~ \Pi x:\tau.K
   \end{align*}

  \begin{align*}
    \tau &::= \mbox{ Ascii } | \mbox{ Nat } | \mbox{ Bool } \\
         &~~| \tau \rightarrow \tau | [\tau] \\
         &~~| \mbox{ Uint } t~t ~|~ \mbox{Array } \tau~t \\
         &~~| \mbox{ Pdu } \{\overline{\ell = \tau}\} ~|~ 
         \mbox{Enum } \{\overline{\tau \rightarrow  \mbox{Bool}, \tau}\} 
  \end{align*}
\end{flushleft}
}

\frame{\frametitle{Steve's Type Constructors}
\begin{flushleft}
   \begin{align*}
      \mbox{uint} &:: \Pi x:\mbox{Nat}.\Pi y:\mbox{Nat}.\mbox{Uint}~x~y \\
      \mbox{array} &:: \Pi \alpha::\star.\Pi y:\mbox{Nat}.\mbox{Uint}~x~y \\
      \mbox{pdu} &:: \Pi x:\{\overline{\ell = \tau}\}.
      \mbox{Pdu}~\{ \overline{\ell = \tau }\} \\
      \mbox{enum} &:: \Pi x:\{\overline{\tau \rightarrow  \mbox{Bool}, \tau}\}.
      \mbox{Enum } \{\overline{\tau \rightarrow  \mbox{Bool}, \tau}\}
   \end{align*}
\end{flushleft}
}

\input{lowlevel.tex}

\subsection{A Theory of Steve}

\frame{\frametitle{Predicate Introduction}
\begin{itemize}
   \item $\Delta$ - set of known facts
   \item conditional terms introduce predicates
   \item evaluate sub-terms using new fact established by predicate
\end{itemize}
 


\begin{prooftree}
   \scriptsize
   \def \fCenter{\ \vdash\ }
   \RightLabel{\textbf{T$_{if}$}}
   \AxiomC{$\Delta | \Gamma \fCenter\ t_1 : Bool$}
   \AxiomC{$\Delta,\{t_1\} | \Gamma \fCenter\ t_2 : \tau$}
   \AxiomC{$\Delta,\{\neg t_1\} | \Gamma \fCenter\ t_3 : \tau$}
   \TrinaryInfC{$\Delta | \Gamma \fCenter\ $ if $t_1$ then $t_2$ else $t_3 : \tau$}
\end{prooftree}

\begin{mathpar}
   \inferrule[K-Proj]{
        \Gamma \vdash \tau_1 :: \star \\
        \Gamma, \langle \tau_{i-1} :: \star \rangle \vdash \tau_i :: \star \\
        \tau,\tau_1 \in RT
      } {
         \Gamma \vdash \mbox{ pdu } \{ \ell_i = \tau_i \} }
\end{mathpar}

}

\frame{\frametitle{Dependency Elimination}
\begin{itemize}
   \item deduce dependency from known facts
   \item eliminate dependency in resulting type
\end{itemize}
 
\begin{prooftree}
   \scriptsize
   \def \fCenter{\ \vdash\ }
   \RightLabel{\textbf{T$_{DepElim_1}$}}
   \AxiomC{$\Delta | \Gamma \fCenter\ t : \tau ? \delta$}
   \AxiomC{$\Delta \vDash \delta$}
   \BinaryInfC{$\Delta | \Gamma \fCenter\ t : \tau$}
\end{prooftree}
}

\frame{\frametitle{Dependency Deferral}
\begin{itemize}
   \item use of type without proof of dependency
   \item rewrite term using conditional
   \item eliminate dependency of type
\end{itemize}
 
\begin{prooftree}
   \scriptsize
   \def \fCenter{\ \vdash\ }
   \RightLabel{\textbf{T$_{DepElim_2}$}}
   \AxiomC{$\Delta | \Gamma \fCenter\ t : \tau ? \delta$}
   \AxiomC{$\Delta \nvDash \delta$}
   \BinaryInfC{$\Delta | \Gamma \fCenter\ t : \tau ? \delta \rightsquigarrow$ if $
   \delta$ then $t$ else $error : \tau$}
\end{prooftree}
}

\frame{\frametitle{Top-Level Rules}

\begin{mathpar}
  \inferrule[T-FUNC]
  { \Sigma;\Gamma \vdash e : \tau \\
    \Sigma; \Gamma, (f:\tau) \vdash prgm : \tau'}
  {\Sigma ; \Gamma \vdash f :: \tau = e, prgm}
\end{mathpar}

\begin{mathpar}
  \inferrule[T-PDU]
  {
    \Sigma; \Gamma \vdash \overline{\ell = \tau}: \tau_i \\
    \Sigma, (id:\tau); \Gamma \vdash prgm : \tau'
  }
  {\Sigma; \Gamma \vdash pdu id \{ \overline{\ell = \tau} \} }
\end{mathpar}

\begin{mathpar}
  \inferrule[T-ENUM]
  { \Sigma; \Gamma \vdash verify all are bool  \\
    \Sigma,(id:\tau); \Gamma,\overline{(t:\tau)} \vdash prgm : \tau'}
  {\Sigma; \Gamma \vdash enum id \{ \overline{t \tau} \}}
\end{mathpar}

\begin{mathpar}
  \inferrule[T-ADT]
  { \Sigma; \Gamma \vdash \\
    \Sigma,(T:\tau_T); \Gamma,\overline{
      (K: \overline{\tau} \to \tau_T \vdash )
    \vdash prgm: \tau'} }
  { data T = \{ \overline{K \overline{\tau}}, prgm \} }
\end{mathpar}

}

\subsection{Steve's interpreter}
