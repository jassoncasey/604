


\section{Contribution}

\subsection{Network Protocol Architecture}



\subsection{Steve: A Network Protocol Specification Language}

\frame{\frametitle{Steve's Terms}

  \begin{flushleft}
  \begin{align*}
  t &::= t~t ~|~ \lambda x:\tau.t ~|~ x ~|~ c ~|~
    \mbox{if } t \mbox{ then } t \mbox{ else } t \\
     &~~|~
    \mbox{let } x:\tau = t \mbox{ in } t ~|~ 
    K~\overline{t} ~|~
    \mbox{case } t \mbox{ of } \{
      \overline{K~\overline{t} \rightarrow t} \}\\
    &~~|~
    \mbox{uint } t~t ~|~ \mbox{ array } \tau~t ~|~ t[t] ~|~ t.\ell ~|~
    id \{ \overline{\ell = t} \} \\
    &~~|~
    \mbox{data } id = \overline{K \overline{\tau}} ~|~
    \mbox{pdu } id = \{ \overline{\ell = \tau} \}
  \end{align*}
\end{flushleft}
}

\frame{\frametitle{Kinds and Types of Steve} 
\begin{flushleft}

   \begin{align*}
      K &::= \star ~|~ \Pi x:\tau.K
   \end{align*}

  \begin{align*}
    \tau &::= \mbox{ Ascii } | \mbox{ Nat } | \mbox{ Bool } \\
         &~~| \tau \rightarrow \tau | [\tau] \\
         &~~| \mbox{ Uint } t~t | \mbox{Array } \tau~t
  \end{align*}
\end{flushleft}
}

\frame{\frametitle{Steve's Type Constructors}
array $t_1$ $t_2$\\
$t_1=$ expression defining the type contained in the array\\
$t_2=$ expression defining the initial/default value of the array\\
 
uint $t_1$ $t_2$\\
$t_1=$ expression defining the number size of this uint in bits\\
$t_2=$ expression defining the initial/default value of this type\\

pad $t$\\
$t=$ expression defining the number of bits to skip\\
}

\subsection{A Theory of Steve}

\frame{\frametitle{Predicate Introduction}
\begin{itemize}
   \item $\Delta$ - set of known facts
   \item conditional terms introduce predicates
   \item evaluate sub-terms using new fact established by predicate
\end{itemize}
 


\begin{prooftree}
   \scriptsize
   \def \fCenter{\ \vdash\ }
   \RightLabel{\textbf{T$_{if}$}}
   \AxiomC{$\Delta | \Gamma \fCenter\ t_1 : Bool$}
   \AxiomC{$\Delta,\{t_1\} | \Gamma \fCenter\ t_2 : \tau$}
   \AxiomC{$\Delta,\{\neg t_1\} | \Gamma \fCenter\ t_3 : \tau$}
   \TrinaryInfC{$\Delta | \Gamma \fCenter\ $ if $t_1$ then $t_2$ else $t_3 : \tau$}
\end{prooftree}

\begin{mathpar}
   \inferrule[K-Proj]{
        \Gamma \vdash \tau_1 :: \star \\
        \Gamma, \langle \tau_{i-1} :: \star \rangle \vdash \tau_i :: \star \\
        \tau,\tau_1 \in RT
      } {
         \Gamma \vdash \mbox{ pdu } \{ \ell_i = \tau_i \} }
\end{mathpar}

}

\frame{\frametitle{Dependency Elimination}
\begin{itemize}
   \item deduce dependency from known facts
   \item eliminate dependency in resulting type
\end{itemize}
 
\begin{prooftree}
   \scriptsize
   \def \fCenter{\ \vdash\ }
   \RightLabel{\textbf{T$_{DepElim_1}$}}
   \AxiomC{$\Delta | \Gamma \fCenter\ t : \tau ? \delta$}
   \AxiomC{$\Delta \vDash \delta$}
   \BinaryInfC{$\Delta | \Gamma \fCenter\ t : \tau$}
\end{prooftree}
}

\frame{\frametitle{Dependency Deferral}
\begin{itemize}
   \item use of type without proof of dependency
   \item rewrite term using conditional
   \item eliminate dependency of type
\end{itemize}
 
\begin{prooftree}
   \scriptsize
   \def \fCenter{\ \vdash\ }
   \RightLabel{\textbf{T$_{DepElim_2}$}}
   \AxiomC{$\Delta | \Gamma \fCenter\ t : \tau ? \delta$}
   \AxiomC{$\Delta \nvDash \delta$}
   \BinaryInfC{$\Delta | \Gamma \fCenter\ t : \tau ? \delta \rightsquigarrow$ if $
   \delta$ then $t$ else $error : \tau$}
\end{prooftree}
}

\subsection{Steve's interpreter}
