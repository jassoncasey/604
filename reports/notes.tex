\documentclass{article}
\usepackage{syntax}
\usepackage{bussproofs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\setlength{\grammarindent}{2.5cm}
\begin{document}

\section{Parsing and Representation}

SPL input files are read and split into a token stream according to the token
syntax regular expressions. Whitespace (WS) tokens are dropped from the input
stream. Identifiers which match the keyword ``let'' are transformed into a 
special Let token. The parser produces a parse tree from the token stream,
which maintains context information from the input file such as: filename, line
and column number. The parser is a LL recursive decent parser which produces a 
intermediate representation. Assuming no issues are encountered the parse
tree is transformed into an AST. The right-associative application produced by
the LL parse is transformed into a left-associative sub-tree during this phase
using sub-tree rotations.

\subsection{Regular Expression}

$Id ::= [a-zA-Z\_][a-zA-Z_0-9]^{*}$\\
$Digits ::= [0-9]^{+}$\\
$Tokens ::= [=.+-*/();]$\\
$WS ::= [$\textbackslash n \textbackslash t $]$

\subsection{Grammar}

\begin{grammar}
<program> ::= <statements>
   \alt $\epsilon$ 

<statements> ::= <statement> <statements>
   \alt <statement>

<statement> ::= <expression> `;'
              
<expression> ::= <term>
   \alt `let' Id `=' <expression>
   \alt `\textbackslash' Id `.' <expression>

<term> ::= <factor>
   \alt <factor> `+' <term>
   \alt <factor> `-' <term>

<factor> ::= <application>
   \alt <application> `*' <factor>
   \alt <application> `/' <factor>

<application> ::= <primary>
   \alt <primary> <application>

<primary> ::= Id
   \alt Digits
   \alt `(' <compound> `)'

<compound> ::= <expression>
   \alt <expression> `;' <compound>
\end{grammar}

\subsection{AST}

\begin{grammar}
<t> ::= $\mathbb{N}$ | $x$ | $let$ $x = t$ | $\lambda x.t$ 
         | $t$ $t$ | $t;t$ | $\delta$ $op$ $t$ $t$

<v> ::= $\mathbb{N}$ | $\lambda x.t$ | $\delta$ $op$ $v$ $v$

<op> ::= $+$ | $-$ | $\times$ | $/$
\end{grammar}

\section{Evaluation}

\begin{prooftree}
\RightLabel{\textbf{$E_{seq1}$}}
\AxiomC{}
\UnaryInfC{$v$; $t\rightarrow t$}
\end{prooftree}
 
\begin{prooftree}
\RightLabel{\textbf{$E_{app1}$}}
\AxiomC{}
\UnaryInfC{$( \lambda x. t_1 )$ $v_2 \rightarrow$[$ x \mapsto v_2$] $t_1$}
\end{prooftree}

\begin{prooftree}
\RightLabel{\textbf{$E_{app2}$}}
\AxiomC{$t_2 \rightarrow t_2'$}
\UnaryInfC{$t_1$ $t_2 \rightarrow t_1$ $t_2'$}
\end{prooftree}
 
\begin{prooftree}
\RightLabel{\textbf{$E_{app3}$}}
\AxiomC{$t_1 \rightarrow t_1'$}
\UnaryInfC{$t_1$ $v_2 \rightarrow t_1'$ $v_2$}
\end{prooftree}

\begin{prooftree}
\RightLabel{\textbf{$E_{seq2}$}}
\AxiomC{$t_1 \rightarrow t_1'$}
\UnaryInfC{$t_1$ ; $t_2 \rightarrow t_1'$ ; $t_2$}
\end{prooftree}

\begin{prooftree}
\RightLabel{\textbf{$E_{\delta1}$}}
\AxiomC{$t_1 \rightarrow t_1'$}
\UnaryInfC{$\delta$ $op$ $t_1$ $t_2 \rightarrow \delta$ $op$ $t_1'$ $t_2$}
\end{prooftree}

\begin{prooftree}
\RightLabel{\textbf{$E_{\delta2}$}}
\AxiomC{$t_2 \rightarrow t_2'$}
\UnaryInfC{$\delta$ $op$ $v_1$ $t_2 \rightarrow \delta$ $op$ $v_1$ $t_2'$}
\end{prooftree}

\section{Testing}

\section{Files}
\subsection{Core files}
\begin{tabular}{|l|l|}
  \hline
{\bf Files}&{\bf Description}\\
  \hline
spl.hs & Main file that initializes the SPL parser.\\
  \hline
Lexer.hs & Module that implements lexing and defines tokens for SPL.\\
  \hline
Parser.hs & Module that implements the parser for SPL.\\
  \hline
ParseTree.hs & Module that defines the SPL parse tree data structure and auxilliary functions.\\
  \hline
Ast.hs & Module that defines the AST data structure for SPL.\\
  \hline
Eval.hs & Module containing evaluation facilities for the SPL.\\
  \hline
\end{tabular}
\subsection{Auxilliary files}
\begin{tabular}{|l|l|}
  \hline
{\bf Files}&{\bf Description}\\
  \hline
Interactive.hs & Module that implements an REPL for SPL.\\
  \hline
CmdOpts.hs & Auxilliary module to handle command-line arguments supplied to the parser.\\
  \hline
test_lexer.hs & Executes tests for the lexer.\\
  \hline
test_parser.hs & Executes tests for the parser.\\
  \hline
PrettyPrint.hs & Module that formats internal data structures for printing.\\
  \hline
\end{tabular}
\end{document}
